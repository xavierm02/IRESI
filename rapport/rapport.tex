\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{listings}
\usepackage{graphicx}
\lstset{language = Caml}

\title{IRESI : Algorithme Misra-Gries}
\author{François \textsc{Godi} \and Xavier \textsc{Montillet}}
\date{Pour le 3 décembre 2013}

\begin{document}
	
\maketitle
% \tableofcontents

\section{Principe de l'algorithme}

	\subsection{Objectif}	
		Cet algorithme a pour but de déterminer quels sont les éléments les plus fréquents d'un flux de données en temps 				réel, c'est à dire en temps linéaire par rapport à $m$, le nombre d'éléments du flux. Pour ce faire il n'utilise que 			$k$ compteurs et, puisque dans les faits $k \ll m$, l'algorithme est économe en mémoire.
	
	\subsection{Fonctionnement}	
		Le fonctionnement de l'algorithme est le suivant : 
		\begin{enumerate}
			\item On commence par initialiser $k$ compteurs vides.
			\item Pour chaque élément $x$ du flux: 
				\begin{itemize}
					\item Si il y a déjà, parmi les $k$ compteurs, un compteur associé à $x$ alors 	on incrémente ce 									compteur.
					\item Sinon, si au moins un des $k$ compteurs est vide, on associe $x$ à l'un des compteurs vides et on 							positionne ce dernier à 1 pour compter l'élément courant du flux.
					\item  Enfin, si les $k$ compteurs sont déjà associés à des éléments du flux tous différents de $x$, on 							décrémente tous les compteurs. Un compteur devenant nul n'est plus associé à aucun élément du flux, 							il redevient un compteur vide.
				\end{itemize}
			\item À la fin de la mesure, les compteurs contiennent nécessairement les valeurs les plus fréquentes du flux, 						sous certaines conditions.
		\end{enumerate}				
	
	\subsection{Conditions de validité}
		Tout élément $j$ du flux dont la fréquence a été strictement plus grande que $m/k$, où $m$ est le nombre d'éléments 			du 	flux et $k$ le nombre de compteurs utilisés, sera nécessairement présent dans l'un des compteurs à la fin de la 			mesure. Pour les éléments du flux dont la fréquence a été inférieure à $m/k$, on ne peut rien dire avec certitude 				mais, si le flux n'est pas pathologique, plus leur fréquence était grande plus ils ont de chances de se trouver dans 			l'un des compteurs à la fin .
	
\section{Implémentation OCaml}
	
	\subsection{Choix du langage}
		Nous avons choisi d'implémenter cet algorithme en OCaml car nous connaissons bien ce langage et nous savions qu'il se 		prête bien à l'implémentation d'un algorithme comme celui ci. Notre code est robuste et peut toujours fonctionner si 			la nature des éléments du flux change, par exemple.
	
	\subsection{Choix d'implémentation}
		Un flux d'éléments de type $\alpha$ est modélisé par un type $\alpha$ enum qui, outre une fonction d'initialisation, 			ne possède qu'une fonction \emph{next} qui renvoie l'élément suivant du flux :
		
		\begin{lstlisting} 
type 'a enum =
  {
    reset: unit -> unit;
    next: unit -> 'a option
  }
		\end{lstlisting}
		
		Notre itérateur permet d'effectuer un traitement quelconque pour chaque élément du flux :
		
		\begin{lstlisting}
let iter f enum =
  let rec aux () =
    match enum.next () with
      | Some x -> begin
        f x;
        aux ()
      end
      | None -> ()
  in
  aux ()
;;
		\end{lstlisting}
		
		En particulier, incrémenter et décrémenter les compteurs selon les éléments du flux. 
		Pour plus de détails sur l'implémentation, se reporter au code source.
		
\section{Résultats}

\begin{figure}[h!]
  \caption{EPA-HTTP}
  \centering
    \includegraphics[scale=0.8]{../output/graph-1.png}
\end{figure}

\begin{figure}[h!]
  \caption{SDSC-HTTP}
  \centering
    \includegraphics[scale=0.8]{../output/graph-2.png}
\end{figure}

\begin{figure}[h!]
  \caption{Calgary-HTTP}
  \centering
    \includegraphics[scale=0.8]{../output/graph-3.png}
\end{figure}

\end{document}